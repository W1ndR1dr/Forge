"""
Enhanced project initialization for Forge.

Scans the codebase, asks clarifying questions about project vision,
and generates project-context.md that feeds into all prompts.
"""

import subprocess
import json
from dataclasses import dataclass, field
from pathlib import Path
from typing import Optional
from rich.console import Console
from rich.prompt import Prompt, Confirm
from rich.panel import Panel
from rich.markdown import Markdown

console = Console()


@dataclass
class ProjectContext:
    """Project context generated during enhanced init."""

    name: str
    description: str = ""
    vision: str = ""
    target_users: str = ""
    tech_stack: list[str] = field(default_factory=list)
    key_features: list[str] = field(default_factory=list)
    coding_philosophy: str = ""
    ai_guidance: str = ""

    def to_markdown(self) -> str:
        """Generate project-context.md content."""
        sections = [
            f"# {self.name} - Project Context",
            "",
            "This file is auto-generated by Forge and feeds into all implementation prompts.",
            "",
        ]

        if self.description:
            sections.extend([
                "## Description",
                self.description,
                "",
            ])

        if self.vision:
            sections.extend([
                "## Vision",
                self.vision,
                "",
            ])

        if self.target_users:
            sections.extend([
                "## Target Users",
                self.target_users,
                "",
            ])

        if self.tech_stack:
            sections.extend([
                "## Tech Stack",
                *[f"- {tech}" for tech in self.tech_stack],
                "",
            ])

        if self.key_features:
            sections.extend([
                "## Key Features",
                *[f"- {feature}" for feature in self.key_features],
                "",
            ])

        if self.coding_philosophy:
            sections.extend([
                "## Coding Philosophy",
                self.coding_philosophy,
                "",
            ])

        if self.ai_guidance:
            sections.extend([
                "## AI Implementation Guidance",
                self.ai_guidance,
                "",
            ])

        return "\n".join(sections)

    def save(self, project_root: Path) -> Path:
        """Save project context to .forge/project-context.md."""
        context_path = project_root / ".forge" / "project-context.md"
        context_path.parent.mkdir(parents=True, exist_ok=True)
        context_path.write_text(self.to_markdown())
        return context_path

    @classmethod
    def load(cls, project_root: Path) -> Optional["ProjectContext"]:
        """Load existing project context if available."""
        context_path = project_root / ".forge" / "project-context.md"
        if not context_path.exists():
            return None
        # For now, just return a minimal context - full parsing can be added later
        return cls(name=project_root.name)


class EnhancedInitializer:
    """
    Enhanced project initialization that understands the codebase.

    Workflow:
    1. Scan existing docs (README, CLAUDE.md, etc.)
    2. Ask clarifying questions about vision
    3. Generate project-context.md
    """

    def __init__(self, project_root: Path):
        self.project_root = project_root

    def scan_existing_docs(self) -> dict[str, str]:
        """Scan existing documentation files."""
        docs = {}

        doc_files = [
            "README.md",
            "CLAUDE.md",
            "docs/README.md",
            "docs/OVERVIEW.md",
            "docs/ARCHITECTURE.md",
            ".github/README.md",
        ]

        for doc_file in doc_files:
            path = self.project_root / doc_file
            if path.exists():
                content = path.read_text()
                # Truncate if too long
                if len(content) > 3000:
                    content = content[:3000] + "\n\n... (truncated)"
                docs[doc_file] = content

        return docs

    def detect_tech_stack(self) -> list[str]:
        """Detect technology stack from project files."""
        stack = []

        # Python
        if (self.project_root / "pyproject.toml").exists():
            stack.append("Python")
        if (self.project_root / "requirements.txt").exists():
            stack.append("Python")

        # JavaScript/Node
        if (self.project_root / "package.json").exists():
            pkg_content = (self.project_root / "package.json").read_text()
            if "react" in pkg_content.lower():
                stack.append("React")
            elif "vue" in pkg_content.lower():
                stack.append("Vue")
            elif "next" in pkg_content.lower():
                stack.append("Next.js")
            else:
                stack.append("Node.js")

        # iOS/macOS
        if (self.project_root / "project.yml").exists():
            stack.append("XcodeGen")
            stack.append("Swift")
        if any(self.project_root.glob("*.xcodeproj")):
            if "Swift" not in stack:
                stack.append("Swift")
        if any(self.project_root.glob("**/*.swift")):
            if "SwiftUI" not in stack:
                # Check for SwiftUI usage
                for swift_file in self.project_root.glob("**/*.swift"):
                    try:
                        if "SwiftUI" in swift_file.read_text():
                            stack.append("SwiftUI")
                            break
                    except:
                        pass

        # Rust
        if (self.project_root / "Cargo.toml").exists():
            stack.append("Rust")

        # Go
        if (self.project_root / "go.mod").exists():
            stack.append("Go")

        return list(set(stack))  # Remove duplicates

    def ask_vision_questions(self, detected_docs: dict[str, str], detected_stack: list[str]) -> ProjectContext:
        """Interactively ask questions to understand project vision."""

        # Project name
        default_name = self.project_root.name
        name = Prompt.ask("Project name", default=default_name)

        # Show what we detected
        if detected_docs:
            console.print(f"\n[dim]Found existing docs: {', '.join(detected_docs.keys())}[/dim]")
        if detected_stack:
            console.print(f"[dim]Detected tech stack: {', '.join(detected_stack)}[/dim]\n")

        # Description
        description = Prompt.ask(
            "Brief project description (1-2 sentences)",
            default=""
        )

        # Vision
        console.print("\n[bold]Project Vision[/bold]")
        console.print("[dim]What's the big picture? What problem does this solve?[/dim]")
        vision = Prompt.ask("Vision", default="")

        # Target users
        console.print("\n[bold]Target Users[/bold]")
        console.print("[dim]Who will use this? What's their skill level?[/dim]")
        target_users = Prompt.ask("Target users", default="")

        # Coding philosophy
        console.print("\n[bold]Coding Philosophy[/bold]")
        console.print("[dim]Any preferences? (e.g., 'prefer simplicity', 'AGI-pilled', 'test-driven')[/dim]")
        coding_philosophy = Prompt.ask("Philosophy", default="")

        # AI guidance
        console.print("\n[bold]AI Implementation Guidance[/bold]")
        console.print("[dim]Special instructions for Claude when implementing features?[/dim]")
        console.print("[dim]e.g., 'Always use plan mode', 'Suggest experts before implementing'[/dim]")
        ai_guidance = Prompt.ask(
            "AI guidance",
            default="Engage plan mode and ultrathink before implementing. Suggest relevant domain experts."
        )

        return ProjectContext(
            name=name,
            description=description,
            vision=vision,
            target_users=target_users,
            tech_stack=detected_stack,
            key_features=[],  # Can be populated from registry later
            coding_philosophy=coding_philosophy,
            ai_guidance=ai_guidance,
        )

    def quick_init(self) -> ProjectContext:
        """Quick init with minimal questions."""
        name = self.project_root.name
        stack = self.detect_tech_stack()

        return ProjectContext(
            name=name,
            tech_stack=stack,
            ai_guidance="Engage plan mode and ultrathink before implementing. Suggest relevant domain experts.",
        )

    def run(self, interactive: bool = True) -> ProjectContext:
        """Run the enhanced initialization."""

        if not interactive:
            return self.quick_init()

        console.print(Panel(
            "[bold]Forge Enhanced Initialization[/bold]\n\n"
            "I'll ask a few questions to understand your project.\n"
            "This context will be included in all implementation prompts.",
            title="Welcome",
        ))

        # Scan existing docs
        detected_docs = self.scan_existing_docs()
        detected_stack = self.detect_tech_stack()

        # Ask questions
        context = self.ask_vision_questions(detected_docs, detected_stack)

        # Preview and confirm
        console.print("\n" + "=" * 60)
        console.print("\n[bold]Generated Project Context:[/bold]\n")
        console.print(Markdown(context.to_markdown()))
        console.print("=" * 60 + "\n")

        if not Confirm.ask("Save this project context?", default=True):
            console.print("[yellow]Initialization cancelled.[/yellow]")
            return None

        return context


def generate_context_with_claude(
    project_root: Path,
    existing_docs: dict[str, str],
) -> Optional[ProjectContext]:
    """
    Use Claude Code CLI to generate project context from existing docs.

    This is an optional enhancement that uses Claude to analyze
    existing documentation and suggest a project context.
    """
    if not existing_docs:
        return None

    # Combine docs for analysis
    docs_text = "\n\n---\n\n".join([
        f"## {name}\n\n{content}"
        for name, content in existing_docs.items()
    ])

    prompt = f"""Analyze these project documents and extract key information.

{docs_text}

---

Based on these documents, provide a JSON object with:
- name: Project name
- description: 1-2 sentence description
- vision: The big picture goal
- target_users: Who uses this
- tech_stack: List of technologies
- coding_philosophy: Any stated preferences

Return ONLY valid JSON, no other text."""

    try:
        result = subprocess.run(
            ["claude", "-p", prompt, "--output-format", "json"],
            capture_output=True,
            text=True,
            timeout=60,
            cwd=project_root,
        )

        if result.returncode == 0:
            data = json.loads(result.stdout)
            result_data = data.get("result", "{}")
            parsed = json.loads(result_data) if isinstance(result_data, str) else result_data
            return ProjectContext(**parsed)
    except Exception as e:
        console.print(f"[dim]Claude analysis unavailable: {e}[/dim]")

    return None
